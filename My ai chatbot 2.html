<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Mind 2.0 Chatbot (Premium)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Highlight.js for code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai-sublime.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Use Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.5s ease;
            height: 100vh;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        /* --- Global Animations --- */
        @keyframes fadeInSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .animate-fadeInSlide {
            animation: fadeInSlide 0.3s ease-out;
        }
        
        /* Custom scrollbar for chat box */
        #chat-box {
            scrollbar-width: thin;
            scrollbar-color: #4f46e5 #e5e7eb;
        }
        #chat-box::-webkit-scrollbar {
            width: 8px;
        }
        #chat-box::-webkit-scrollbar-track {
            background: #e5e7eb;
            border-radius: 10px;
        }
        #chat-box::-webkit-scrollbar-thumb {
            background-color: #4f46e5;
            border-radius: 10px;
            border: 2px solid #e5e7eb;
        }

        /* Message styling adjustments */
        .ai-message {
            background-color: #f3f4f6; /* Subtle light gray */
            border-left: 4px solid #4f46e5; /* Indigo accent */
            color: #1f2937;
        }

        /* API Key status */
        #api-key-status.valid {
            background-color: #10b981; /* Emerald green */
        }
        #api-key-status.invalid {
            background-color: #f59e0b; /* Amber */
        }

        /* Mode buttons */
        .mode-btn {
            @apply py-2 px-3 bg-white text-gray-700 font-semibold rounded-lg shadow-md transition duration-300 transform hover:bg-indigo-50 hover:scale-[1.02] active:scale-[0.98] border border-gray-200 text-sm;
        }
        .mode-btn.active {
            @apply bg-indigo-600 text-white shadow-lg border-indigo-700;
        }
    </style>
</head>
<body class="bg-gray-50 flex flex-col h-screen antialiased">

    <!-- API Key and Header -->
    <div id="header" class="w-full bg-white shadow-lg p-4 flex justify-between items-center z-10">
        <h1 class="text-3xl font-extrabold text-indigo-700 tracking-tight">Nexus Mind 2.0</h1>
        
        <div class="flex items-center space-x-4">
            <!-- API Key Status Indicator -->
            <span id="api-key-status" class="text-white text-xs font-bold px-3 py-1 rounded-full shadow-md transition duration-300 cursor-pointer" onclick="toggleApiKeyInput(true)">
                API Key Status
            </span>

            <!-- API Key Input Field (Hidden by default) -->
            <div id="api-key-container" class="flex items-center space-x-2 transition-all duration-300 max-w-0 overflow-hidden opacity-0">
                <input type="password" id="api-key-input" placeholder="Enter Gemini API Key" 
                       class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-indigo-500 focus:border-indigo-500 w-64">
                <button onclick="saveApiKey()" class="bg-indigo-500 hover:bg-indigo-600 text-white py-2 px-4 rounded-lg text-sm font-semibold transition duration-300">Save</button>
            </div>
        </div>
    </div>

    <!-- Main Chat Area -->
    <div class="flex-grow flex flex-col p-4 overflow-hidden relative">
        
        <!-- Mode Information -->
        <div class="bg-indigo-50 p-4 rounded-xl shadow-inner mb-4 flex justify-between items-center flex-wrap gap-3">
            <div>
                <h2 id="mode-title" class="text-xl font-bold text-indigo-800">NARRATIVE Mode</h2>
                <p id="mode-description" class="text-sm text-indigo-600 mt-1">Chat naturally with the model. Grounding search is off.</p>
            </div>
            
            <!-- Gemini-powered Summary Feature -->
            <button id="summarize-btn" onclick="generateSummary()" class="py-2 px-4 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-lg shadow-md transition duration-300 transform hover:scale-[1.02] active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 text-sm">
                ‚ú® Summarize Chat
            </button>
        </div>

        <!-- Chat History -->
        <div id="chat-box" class="flex-grow overflow-y-auto space-y-4 pr-2 pb-4">
            <!-- Messages will be injected here -->
        </div>

        <!-- Mode Selector and Input Area -->
        <div class="bg-white p-4 rounded-xl shadow-2xl flex flex-col space-y-3 z-10">
            
            <!-- Mode Selector -->
            <div id="mode-selector" class="flex flex-wrap gap-2">
                <button class="mode-btn active" data-mode="Narrative">üí¨ NARRATIVE</button>
                <button class="mode-btn" data-mode="Coding">üíª CODING</button>
                <button class="mode-btn" data-mode="Wiki">üåê WIKI (Grounded)</button>
                <button class="mode-btn" data-mode="Imagine">üñºÔ∏è IMAGINE (Image Gen)</button>
            </div>

            <!-- Input Bar -->
            <div class="flex space-x-3">
                <input type="text" id="user-input" placeholder="Ask a question..."
                       class="flex-grow px-4 py-3 border border-gray-300 rounded-xl focus:ring-indigo-500 focus:border-indigo-500 shadow-inner transition duration-150">
                <button id="send-btn" onclick="sendMessage()"
                        class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-300 transform hover:scale-[1.02] active:scale-[0.98] focus:outline-none focus:ring-4 focus:ring-indigo-300">
                    Send
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS AND STATE ---
        const API_KEY_STORAGE_KEY = 'geminiApiKey';
        let GEMINI_API_KEY = '';
        let chatHistory = [];
        let currentMode = 'Narrative'; // Default mode

        // API URLs
        const GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=";
        const IMAGEN_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=";
        const IMAGEN_MODEL_NAME = "Imagen 3.0";
        const MAX_CHATS = 10; // Maximum number of messages to keep in history for context

        const MODE = {
            NARRATIVE: 'Narrative',
            CODING: 'Coding',
            WIKI: 'Wiki',
            IMAGINE: 'Imagine' // New mode
        };

        // --- DOM ELEMENTS ---
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const modeTitle = document.getElementById('mode-title');
        const modeDescription = document.getElementById('mode-description');
        const apiKeyInput = document.getElementById('api-key-input');
        const apiKeyContainer = document.getElementById('api-key-container');
        const apiKeyStatus = document.getElementById('api-key-status');
        const modeSelector = document.getElementById('mode-selector');

        // --- UTILITY FUNCTIONS ---

        // Function to convert role name for display
        function getRoleDisplay(role) {
            switch (role) {
                case 'user': return 'You';
                case 'ai': return 'Nexus Mind';
                case 'system': return 'System Message';
                case 'error': return 'Error';
                default: return 'Bot';
            }
        }

        /**
         * Converts markdown text to HTML, handles bold, italics, and code blocks.
         * @param {string} text The markdown text.
         * @returns {string} The HTML string.
         */
        function formatMarkdown(text) {
            // Escape HTML characters first
            let html = text.replace(/&/g, '&amp;')
                           .replace(/</g, '&lt;')
                           .replace(/>/g, '&gt;');

            // 1. Code blocks (```language ... ```) - Handle these first to prevent interior formatting
            html = html.replace(/```(\w+)?\n([\s\S]+?)```/g, (match, lang, code) => {
                const codeBlock = `<pre><code class="${lang || 'plaintext'}">${code}</code></pre>`;
                return codeBlock;
            });

            // 2. Bold
            html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
            
            // 3. Italics
            html = html.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
            
            // 4. Newlines to breaks
            html = html.replace(/\n/g, '<br>');

            return html;
        }

        /**
         * Creates and displays a message in the chat box.
         * @param {string} text The message content.
         * @param {string} role 'user', 'ai', 'system', or 'error'.
         * @param {Array<Object>} sources Array of source objects for grounding.
         */
        function displayMessage(text, role, sources) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('flex', 'space-x-3', 'animate-fadeInSlide');
            messageWrapper.setAttribute('data-role', role);

            const avatar = document.createElement('div');
            avatar.classList.add('w-8', 'h-8', 'rounded-full', 'flex', 'items-center', 'justify-center', 'text-white', 'text-xs', 'font-bold', 'flex-shrink-0');
            
            const messageBubble = document.createElement('div');
            messageBubble.classList.add('p-4', 'rounded-xl', 'shadow-md', 'break-words', 'w-full', 'max-w-4xl', 'transition-all', 'duration-300', 'message-text-container');
            
            const roleDisplay = document.createElement('p');
            roleDisplay.classList.add('text-sm', 'font-semibold', 'mb-1');

            if (role === 'user') {
                messageWrapper.classList.add('justify-end');
                avatar.textContent = 'U';
                avatar.classList.add('bg-gray-500', 'order-2');
                messageBubble.classList.add('bg-indigo-500', 'text-white', 'order-1', 'rounded-br-none');
                roleDisplay.textContent = getRoleDisplay(role);
                roleDisplay.classList.add('text-indigo-200');
            } else {
                messageWrapper.classList.add('justify-start');
                avatar.textContent = role === 'ai' ? 'AI' : (role === 'system' ? '‚öôÔ∏è' : 'üö®');
                avatar.classList.add('bg-indigo-600', 'order-1');
                messageBubble.classList.add('ai-message', 'rounded-tl-none', 'order-2');
                
                if (role === 'error') {
                    messageBubble.classList.replace('ai-message', 'bg-red-100');
                    messageBubble.style.borderLeftColor = '#ef4444';
                    roleDisplay.textContent = getRoleDisplay(role);
                    roleDisplay.classList.add('text-red-700');
                    avatar.classList.replace('bg-indigo-600', 'bg-red-600');
                } else {
                    roleDisplay.textContent = getRoleDisplay(role);
                    roleDisplay.classList.add('text-indigo-700');
                }
            }

            // Text content
            const textContent = document.createElement('div');
            textContent.classList.add('message-text', 'text-base', 'leading-relaxed');
            textContent.innerHTML = formatMarkdown(text);
            
            messageBubble.appendChild(roleDisplay);
            messageBubble.appendChild(textContent);

            // Append parts
            messageWrapper.appendChild(avatar);
            messageWrapper.appendChild(messageBubble);

            // Add Grounding Sources if present
            if (sources && sources.length > 0) {
                const sourcesDiv = document.createElement('div');
                sourcesDiv.classList.add('mt-2', 'pt-2', 'border-t', 'border-gray-200', 'text-xs', 'text-gray-500', 'w-full');
                sourcesDiv.innerHTML = '<strong>Sources:</strong> ' + sources.map(s => 
                    `<a href="${s.uri}" target="_blank" class="text-indigo-600 hover:text-indigo-800 hover:underline">${s.title.substring(0, 50)}...</a>`
                ).join(', ');
                messageBubble.appendChild(sourcesDiv);
            }

            chatBox.appendChild(messageWrapper);
            
            // Highlight code blocks
            messageBubble.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });

            // Scroll to bottom
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // Display welcome message on load
        function displayWelcomeMessage() {
            displayMessage("Hello! I'm Nexus Mind 2.0. Choose a mode to begin. Try the new üñºÔ∏è IMAGINE mode or the ‚ú® Summarize Chat feature!", 'system', []);
        }

        // --- API KEY HANDLING ---
        function updateApiKeyStatus(isValid) {
            apiKeyStatus.textContent = isValid ? 'Key Valid (Click to Change)' : 'Key Missing/Invalid (Click to Enter)';
            apiKeyStatus.classList.remove('valid', 'invalid');
            apiKeyStatus.classList.add(isValid ? 'valid' : 'invalid');
        }

        function toggleApiKeyInput(show) {
            if (show) {
                apiKeyContainer.classList.remove('max-w-0', 'opacity-0');
                apiKeyContainer.classList.add('max-w-screen-sm', 'opacity-100');
                apiKeyInput.focus();
            } else {
                apiKeyContainer.classList.remove('max-w-screen-sm', 'opacity-100');
                apiKeyContainer.classList.add('max-w-0', 'opacity-0');
            }
        }

        function saveApiKey() {
            const key = apiKeyInput.value.trim();
            if (key) {
                GEMINI_API_KEY = key;
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                updateApiKeyStatus(true);
                toggleApiKeyInput(false);
                displayMessage("API Key saved successfully. You can now use all modes!", 'system', []);
            } else {
                displayMessage("Please enter a valid API Key.", 'error', []);
                updateApiKeyStatus(false);
            }
        }

        // --- CHAT MODE LOGIC ---
        modeSelector.addEventListener('click', (event) => {
            const button = event.target.closest('.mode-btn');
            if (button) {
                const mode = button.getAttribute('data-mode');
                applyMode(mode);
                // Update active state
                modeSelector.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.getAttribute('data-mode') === mode);
                });
            }
        });

        function applyMode(mode) {
            currentMode = mode;
            chatHistory = []; // Clear history on mode switch

            // Welcome message for new mode
            displayWelcomeMessage(); 

            switch (mode) {
                case MODE.NARRATIVE:
                    modeTitle.textContent = 'NARRATIVE Mode';
                    modeDescription.innerHTML = 'Chat naturally with the model. Grounding search is off.';
                    userInput.placeholder = 'e.g., Explain the concept of general relativity...';
                    break;
                case MODE.CODING:
                    modeTitle.textContent = 'CODING Mode';
                    modeDescription.innerHTML = 'Ask the model to generate, explain, or debug code snippets.';
                    userInput.placeholder = 'e.g., Write a Python function for a quicksort algorithm...';
                    break;
                case MODE.WIKI:
                    modeTitle.textContent = 'WIKI Mode (Grounded)';
                    modeDescription.innerHTML = 'Ask real-time questions. Model uses Google Search for current, grounded information.';
                    userInput.placeholder = 'e.g., What are the current top headlines in tech?';
                    break;
                case MODE.IMAGINE:
                    modeTitle.textContent = `IMAGINE Mode (Image Generation)`;
                    modeDescription.innerHTML = `Describe the image you want to create. Powered by ${IMAGEN_MODEL_NAME}. **Note: This does not use chat history context.**`;
                    userInput.placeholder = 'e.g., A watercolor painting of a cat wearing a tiny crown...';
                    break;
                default:
                    modeTitle.textContent = 'Unknown Mode';
                    modeDescription.innerHTML = 'Please select a valid mode.';
                    break;
            }
            userInput.focus();
        }

        // --- GEMINI API CALL (TEXT GENERATION) ---

        /**
         * Cleans up history and prepares content for the Gemini API call.
         * @returns {Array<Object>} The cleaned chat history.
         */
        function getApiHistory() {
            // Filter out system and error messages and limit history size
            const conversation = chatHistory
                .filter(msg => msg.role !== 'system' && msg.role !== 'error')
                .slice(-MAX_CHATS * 2); // Keep last N user/model turns

            // Map the simple history objects to the API's required format
            return conversation.map(msg => ({
                role: msg.role === 'ai' ? 'model' : 'user',
                parts: [{ text: msg.text }]
            }));
        }

        async function handleTextMode(query) {
            if (!GEMINI_API_KEY) {
                displayMessage("Please enter your API Key before sending a message.", 'error', []);
                return;
            }

            const apiHistory = getApiHistory();
            apiHistory.push({ role: "user", parts: [{ text: query }] });

            let systemPrompt = "You are a friendly, helpful, and insightful AI assistant. You respond clearly and concisely. Use markdown for formatting.";
            let tools = [];

            if (currentMode === MODE.CODING) {
                systemPrompt = "You are an expert software developer. Respond with code snippets using markdown code blocks and clear explanations. Focus on the requested language/task.";
            } else if (currentMode === MODE.WIKI) {
                systemPrompt = "You are a current events and knowledge expert. Use Google Search grounding to ensure your answers are factual and up-to-date. Provide short, clear responses and cite your sources.";
                tools = [{ "google_search": {} }];
            }

            const apiUrl = `${GEMINI_API_BASE_URL}${GEMINI_API_KEY}`;
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: apiHistory,
                        tools: tools.length > 0 ? tools : undefined,
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const text = candidate.content.parts[0].text;
                    
                    // 6. Extract grounding sources
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    // 7. Store and Display AI response
                    chatHistory.push({ role: "ai", text: text });
                    displayMessage(text, 'ai', sources);
                    userInput.focus();
                } else {
                    displayMessage("The model returned an empty response. Please try rephrasing your query.", 'error', []);
                }

            } catch (error) {
                console.error("Gemini API error:", error);
                displayMessage(`Request failed: ${error.message.substring(0, 150)}... Check console for full details.`, 'error', []);
            }
        }

        // --- IMAGEN API CALL (IMAGE GENERATION) ---

        /**
         * Handles the image generation request using Imagen 3.0.
         * @param {string} prompt The user's image description.
         */
        async function handleImagineMode(prompt) {
            if (!GEMINI_API_KEY) {
                displayMessage("Please enter your API Key to use image generation.", 'error', []);
                return;
            }

            displayMessage(`Generating image for: "${prompt}"...`, 'system', []);

            // The payload for Imagen 3.0
            const payload = {
                instances: [{ prompt: prompt }],
                parameters: { "sampleCount": 1 }
            };

            const apiUrl = `${IMAGEN_API_BASE_URL}${GEMINI_API_KEY}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
                }

                const result = await response.json();
                const base64Data = result?.predictions?.[0]?.bytesBase64Encoded;

                if (base64Data) {
                    const imageUrl = `data:image/png;base64,${base64Data}`;
                    displayImageMessage(imageUrl, prompt);
                } else {
                    displayMessage("Image generation failed. The model returned no image data.", 'error', []);
                }

            } catch (error) {
                console.error("Image generation error:", error);
                displayMessage(`Image generation failed due to an error. Check console for details. Error: ${error.message.substring(0, 150)}...`, 'error', []);
            }
        }

        /**
         * Displays the generated image in the chat box.
         * @param {string} imageUrl The base64 image URL.
         * @param {string} prompt The prompt used to generate the image.
         */
        function displayImageMessage(imageUrl, prompt) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('flex', 'space-x-3', 'animate-fadeInSlide', 'justify-start');
            messageWrapper.setAttribute('data-role', 'ai');

            const avatar = document.createElement('div');
            avatar.textContent = 'AI';
            avatar.classList.add('w-8', 'h-8', 'rounded-full', 'flex', 'items-center', 'justify-center', 'text-white', 'text-xs', 'font-bold', 'flex-shrink-0', 'bg-indigo-600');
            
            const messageContainer = document.createElement('div');
            messageContainer.classList.add('p-4', 'rounded-xl', 'shadow-md', 'break-words', 'w-full', 'max-w-md', 'transition-all', 'duration-300', 'bg-gray-100', 'border-l-4', 'border-indigo-500');

            const promptTitle = document.createElement('p');
            promptTitle.classList.add('text-sm', 'text-gray-600', 'mb-2', 'font-medium');
            promptTitle.textContent = `Generated Image: "${prompt}"`;
            messageContainer.appendChild(promptTitle);

            const imageElement = document.createElement('img');
            imageElement.src = imageUrl;
            imageElement.alt = prompt;
            imageElement.classList.add('max-w-full', 'h-auto', 'rounded-lg', 'shadow-xl', 'mt-2', 'border-2', 'border-indigo-500/50');
            imageElement.onerror = () => {
                imageElement.style.display = 'none';
                const errorText = document.createElement('p');
                errorText.classList.add('text-red-500');
                errorText.textContent = 'Could not load the generated image.';
                messageContainer.appendChild(errorText);
            };
            
            messageContainer.appendChild(imageElement);
            messageWrapper.appendChild(avatar);
            messageWrapper.appendChild(messageContainer);
            
            chatBox.appendChild(messageWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // --- GEMINI API CALL (SUMMARY FEATURE) ---

        /**
         * Generates a summary of the current chat history using Gemini.
         */
        async function generateSummary() {
            if (!GEMINI_API_KEY) {
                displayMessage("Please enter your API Key to use the summary feature.", 'error', []);
                return;
            }

            // Extract visible conversation history from the DOM for the most accurate view
            const historyElements = document.querySelectorAll('#chat-box > div:not([data-role="system"]):not([data-role="error"])');
            if (historyElements.length < 2) {
                displayMessage("No conversation detected to summarize. Send a few messages first!", 'system', []);
                return;
            }

            displayMessage("Generating summary of the conversation...", 'system', []);

            const conversation = Array.from(historyElements).map(el => {
                const role = el.getAttribute('data-role');
                const textElement = el.querySelector('.message-text');
                // The text is stored in innerHTML with <br>s for newlines, so we extract textContent
                const text = textElement ? textElement.textContent.trim() : ''; 
                // Map 'user' and 'ai' roles to 'user' and 'model' for the API
                const apiRole = role === 'user' ? 'user' : 'model';
                return { role: apiRole, parts: [{ text: text }] };
            }).filter(msg => msg.parts[0].text.length > 0);
            
            // Limit to the last N turns for efficiency
            const limitedConversation = conversation.slice(-MAX_CHATS * 2);

            const systemPrompt = "You are a concise summary generator. Based on the provided conversation history, generate a single, clear, and well-structured paragraph that summarizes the main topics and conclusions. Focus on key information.";
            const userQuery = "Please summarize the preceding conversation.";

            // Append the final user query to the conversation
            const fullContents = [...limitedConversation, { role: 'user', parts: [{ text: userQuery }] }];

            const apiUrl = `${GEMINI_API_BASE_URL}${GEMINI_API_KEY}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: fullContents,
                        systemInstruction: {
                            parts: [{ text: systemPrompt }]
                        },
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
                }

                const result = await response.json();
                const summaryText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (summaryText) {
                    displayMessage(`**Conversation Summary:**\n${summaryText}`, 'ai', []);
                } else {
                    displayMessage("Summary generation failed. The model returned no text.", 'error', []);
                }

            } catch (error) {
                console.error("Summary generation error:", error);
                displayMessage(`Summary generation failed: ${error.message.substring(0, 150)}...`, 'error', []);
            }
        }


        // --- MAIN SEND LOGIC ---
        async function sendMessage() {
            const query = userInput.value.trim();
            if (!query) return;

            // 1. Display user message
            displayMessage(query, 'user', []);
            chatHistory.push({ role: "user", text: query });
            userInput.value = '';

            if (currentMode === MODE.IMAGINE) {
                // 2. Handle image generation mode
                await handleImagineMode(query);
                return; // Stop further processing for Imagine mode
            }
            
            // 3. Handle text generation modes (NARRATIVE, CODING, WIKI)
            await handleTextMode(query);
        }

        // Add event listener for Enter key
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Initialize focus and API key check on load
        window.onload = () => {
            // Load key from storage
            const storedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (storedKey) {
                GEMINI_API_KEY = storedKey;
                apiKeyInput.value = storedKey;
                updateApiKeyStatus(true);
            } else {
                updateApiKeyStatus(false);
                toggleApiKeyInput(true); // Automatically show input on first load if key is missing
            }

            // Initializing applyMode will automatically show the welcome message
            applyMode(MODE.NARRATIVE); 
            // Select the initial mode button as active
            document.querySelector(`.mode-btn[data-mode="${MODE.NARRATIVE}"]`).classList.add('active');
            userInput.focus();
        }
    </script>
</body>
</html>
